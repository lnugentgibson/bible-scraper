const chai = require('chai');
const chaiIterator = require('chai-iterator');
chai.use(chaiIterator);
const {
  expect
} = chai;
chai.should();
const sinon = require('sinon');
const _ = require('lodash');

const oaStruct = require('./oa_struct.js');
oaStruct.Register('_', () => _, []);
require('./btree.js');
require('./trie.js');
require('./lexographic.js');

describe('lexographic.js', function() {

describe('LexographicNode', function() {
  let LexographicNode, BTreeNode, TrieNode, RadixTreeNode;
  beforeEach(function() {
    LexographicNode = oaStruct.get('LexographicNode');
    BTreeNode = oaStruct.get('btreeNode');
    TrieNode = oaStruct.get('trieNode');
    RadixTreeNode = oaStruct.get('radixTreeNode');
  });
  it('is not null', function() {
    expect(LexographicNode).to.not.be.null;
  });
  it('size', function() {
    let tree1 = {
      unique: true,
      max: 3,
      compare(a, b) {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }
    }, tree2;
    let node = {
      tree: {
        levels: [
          {
            service: BTreeNode,
            config: tree1
          }
        ]
      },
      root: {
        entries: [{key: 5}],
        children: [
          {
            entries: [{key: 1.25}, {key: 2.5}, {key: 3.75}],
            children: [
              {
                entries: [{key: .625}],
                tree: tree1
              },
              {
                entries: [{key: 1.875}],
                tree: tree1
              },
              {
                entries: [{key: 3.125}],
                tree: tree1
              },
              {
                entries: [{key: 4.375}],
                tree: tree1
              }
            ],
            tree: tree1
          },
          {
            entries: [{key: 7.5}],
            children: [
              {
                entries: [{key: 6.25}],
                tree: tree1
              },
              {
                entries: [{key: 8.75}],
                tree: tree1
              }
            ],
            tree: tree1
          }
        ],
        tree: tree1
      }
    };
    expect(LexographicNode.size(node)).to.equal(11);
    tree1 = {
      unique: true
    };
    node = {
      tree: {
        levels: [
          {
            service: TrieNode,
            config: tree1
          }
        ]
      },
      root: {
        tree: tree1,
        val: 9,
        children: {
          a: {
            tree: tree1,
            children: {
              l: {
                tree: tree1,
                children: {
                  p: {
                    tree: tree1,
                    children: {
                      h: {
                        tree: tree1,
                        children: {
                          a: {
                            tree: tree1,
                            val: 5,
                            children: {
                              b: {
                                tree: tree1,
                                children: {
                                  e: {
                                    tree: tree1,
                                    children: {
                                      t: {
                                        tree: tree1,
                                        val: 3,
                                        children: {}
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  e: {
                    tree: tree1,
                    children: {
                      p: {
                        tree: tree1,
                        children: {
                          h: {
                            tree: tree1,
                            val: 8,
                            children: {}
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    expect(LexographicNode.size(node)).to.equal(4);
    tree1 = {
      unique: true
    };
    tree2 = {
      unique: true,
      max: 3,
      compare(a, b) {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }
    };
    node = {
      tree: {
        levels: [
          {
            service: RadixTreeNode,
            config: tree1
          },
          {
            service: BTreeNode,
            config: tree2
          }
        ]
      },
      root: {
        tree: tree1,
        val: {
          tree: tree2,
          entries: [{key: 1}, {key: 9}]
        },
        children: {
          al: {
            tree: tree1,
            children: {
              pha: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 5}],
                  children: [
                    {
                      tree: tree2,
                      entries: [{key: 3},{key: 4}]
                    },
                    {
                      tree: tree2,
                      entries: [{key: 7},{key: 11}]
                    }
                  ]
                },
                children: {
                  bet: {
                    tree: tree1,
                    val: {
                      tree: tree2,
                      entries: [{key: 0}]
                    },
                    children: {}
                  }
                }
              },
              eph: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 9}]
                },
                children: {}
              }
            }
          }
        }
      }
    };
    expect(LexographicNode.size(node)).to.equal(9);
  });
  it('get', function() {
    let tree1 = {
      unique: true,
      max: 3,
      compare(a, b) {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }
    }, tree2;
    let node = {
      tree: {
        levels: [
          {
            service: BTreeNode,
            config: tree1
          }
        ]
      },
      root: {
        entries: [{key: 5}],
        children: [
          {
            entries: [{key: 1.25}, {key: 2.5, val: '2.5'}, {key: 3.75}],
            children: [
              {
                entries: [{key: .625}],
                tree: tree1
              },
              {
                entries: [{key: 1.875}],
                tree: tree1
              },
              {
                entries: [{key: 3.125}],
                tree: tree1
              },
              {
                entries: [{key: 4.375}],
                tree: tree1
              }
            ],
            tree: tree1
          },
          {
            entries: [{key: 7.5}],
            children: [
              {
                entries: [{key: 6.25}],
                tree: tree1
              },
              {
                entries: [{key: 8.75}],
                tree: tree1
              }
            ],
            tree: tree1
          }
        ],
        tree: tree1
      }
    };
    expect(LexographicNode.at(node, [2.5])).to.equal('2.5');
    expect(LexographicNode.at(node, [2.6])).to.equal(undefined);
    tree1 = {
      unique: true
    };
    node = {
      tree: {
        levels: [
          {
            service: TrieNode,
            config: tree1
          }
        ]
      },
      root: {
        tree: tree1,
        val: 9,
        children: {
          a: {
            tree: tree1,
            children: {
              l: {
                tree: tree1,
                children: {
                  p: {
                    tree: tree1,
                    children: {
                      h: {
                        tree: tree1,
                        children: {
                          a: {
                            tree: tree1,
                            val: 5,
                            children: {
                              b: {
                                tree: tree1,
                                children: {
                                  e: {
                                    tree: tree1,
                                    children: {
                                      t: {
                                        tree: tree1,
                                        val: 3,
                                        children: {}
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  e: {
                    tree: tree1,
                    children: {
                      p: {
                        tree: tree1,
                        children: {
                          h: {
                            tree: tree1,
                            val: 8,
                            children: {}
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    expect(LexographicNode.at(node, ['alpha'])).to.equal(5);
    expect(LexographicNode.at(node, ['x'])).to.equal(undefined);
    tree1 = {
      unique: true
    };
    tree2 = {
      unique: true,
      max: 3,
      compare(a, b) {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }
    };
    node = {
      tree: {
        levels: [
          {
            service: RadixTreeNode,
            config: tree1
          },
          {
            service: BTreeNode,
            config: tree2
          }
        ]
      },
      root: {
        tree: tree1,
        val: {
          tree: tree2,
          entries: [{key: 1}, {key: 9, val: '9'}]
        },
        children: {
          al: {
            tree: tree1,
            children: {
              pha: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 5, val: '5'}],
                  children: [
                    {
                      tree: tree2,
                      entries: [{key: 3},{key: 4}]
                    },
                    {
                      tree: tree2,
                      entries: [{key: 7},{key: 11}]
                    }
                  ]
                },
                children: {
                  bet: {
                    tree: tree1,
                    val: {
                      tree: tree2,
                      entries: [{key: 0}]
                    },
                    children: {}
                  }
                }
              },
              eph: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 9}]
                },
                children: {}
              }
            }
          }
        }
      }
    };
    expect(LexographicNode.at(node, ['', 9])).to.equal('9');
    expect(LexographicNode.at(node, ['alpha', 5])).to.equal('5');
    expect(LexographicNode.at(node, ['x', 7])).to.equal(undefined);
    expect(LexographicNode.at(node, ['alpha', -1])).to.equal(undefined);
  });
  it('iterators', function() {
    let tree1 = {
      unique: true,
      max: 3,
      compare(a, b) {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }
    }, tree2;
    let node = {
      tree: {
        levels: [
          {
            service: BTreeNode,
            config: tree1
          }
        ]
      },
      root: {
        entries: [{key: 5, val: 7}],
        children: [
          {
            entries: [{key: 1.25, val: 1}, {key: 2.5, val: 3}, {key: 3.75, val: 5}],
            children: [
              {
                entries: [{key: .625, val: 0}],
                tree: tree1
              },
              {
                entries: [{key: 1.875, val: 2}],
                tree: tree1
              },
              {
                entries: [{key: 3.125, val: 4}],
                tree: tree1
              },
              {
                entries: [{key: 4.375, val: 6}],
                tree: tree1
              }
            ],
            tree: tree1
          },
          {
            entries: [{key: 7.5, val: 9}],
            children: [
              {
                entries: [{key: 6.25, val: 8}],
                tree: tree1
              },
              {
                entries: [{key: 8.75, val: 10}],
                tree: tree1
              }
            ],
            tree: tree1
          }
        ],
        tree: tree1
      }
    };
    LexographicNode.inOrderGenerator(node).should.deep.iterate.over([
      {key: [.625], val: 0}, {key: [1.25], val: 1}, {key: [1.875], val: 2},
      {key: [2.5], val: 3}, {key: [3.125], val: 4}, {key: [3.75], val: 5},
      {key: [4.375], val: 6}, {key: [5], val: 7}, {key: [6.25], val: 8},
      {key: [7.5], val: 9}, {key: [8.75], val: 10}
    ]);
    tree1 = {
      unique: true
    };
    node = {
      tree: {
        levels: [
          {
            service: TrieNode,
            config: tree1
          }
        ]
      },
      root: {
        tree: tree1,
        val: 9,
        children: {
          a: {
            tree: tree1,
            children: {
              l: {
                tree: tree1,
                children: {
                  p: {
                    tree: tree1,
                    children: {
                      h: {
                        tree: tree1,
                        children: {
                          a: {
                            tree: tree1,
                            val: 5,
                            children: {
                              b: {
                                tree: tree1,
                                children: {
                                  e: {
                                    tree: tree1,
                                    children: {
                                      t: {
                                        tree: tree1,
                                        val: 3,
                                        children: {}
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  e: {
                    tree: tree1,
                    children: {
                      p: {
                        tree: tree1,
                        children: {
                          h: {
                            tree: tree1,
                            val: 8,
                            children: {}
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    LexographicNode.inOrderGenerator(node).should.deep.iterate.over([
      {key: [''], val: 9},
      {key: ['aleph'], val: 8},
      {key: ['alpha'], val: 5},
      {key: ['alphabet'], val: 3}
    ]);
    tree1 = {
      unique: true
    };
    tree2 = {
      unique: true,
      max: 3,
      compare(a, b) {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }
    };
    node = {
      tree: {
        levels: [
          {
            service: RadixTreeNode,
            config: tree1
          },
          {
            service: BTreeNode,
            config: tree2
          }
        ]
      },
      root: {
        tree: tree1,
        val: {
          tree: tree2,
          entries: [{key: 1, val: '1'}, {key: 9, val: '9'}]
        },
        children: {
          al: {
            tree: tree1,
            children: {
              pha: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 5, val: '5'}],
                  children: [
                    {
                      tree: tree2,
                      entries: [{key: 3, val: '3'},{key: 4, val: '4'}]
                    },
                    {
                      tree: tree2,
                      entries: [{key: 7, val: '7'},{key: 11, val: '11'}]
                    }
                  ]
                },
                children: {
                  bet: {
                    tree: tree1,
                    val: {
                      tree: tree2,
                      entries: [{key: 0, val: '0'}]
                    },
                    children: {}
                  }
                }
              },
              eph: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 9, val: '9'}]
                },
                children: {}
              }
            }
          }
        }
      }
    };
    LexographicNode.inOrderGenerator(node).should.deep.iterate.over([
      {key: ['', 1], val: '1'},
      {key: ['', 9], val: '9'},
      {key: ['aleph', 9], val: '9'},
      {key: ['alpha', 3], val: '3'},
      {key: ['alpha', 4], val: '4'},
      {key: ['alpha', 5], val: '5'},
      {key: ['alpha', 7], val: '7'},
      {key: ['alpha', 11], val: '11'},
      {key: ['alphabet', 0], val: '0'}
    ]);
  });
  it('add', function() {
    let tree1 = {
      unique: true,
      max: 3,
      compare(a, b) {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }
    }, tree2;
    let node = {
      tree: {
        levels: [
          {
            service: BTreeNode,
            config: tree1
          }
        ]
      },
      root: {
        entries: [{key: 5, val: 7}],
        children: [
          {
            entries: [{key: 1.25, val: 1}, {key: 2.5, val: 3}, {key: 3.75, val: 5}],
            children: [
              {
                entries: [{key: .625, val: 0}],
                tree: tree1
              },
              {
                entries: [{key: 1.875, val: 2}],
                tree: tree1
              },
              {
                entries: [{key: 3.125, val: 4}],
                tree: tree1
              },
              {
                entries: [{key: 4.375, val: 6}],
                tree: tree1
              }
            ],
            tree: tree1
          },
          {
            entries: [{key: 7.5, val: 9}],
            children: [
              {
                entries: [{key: 6.25, val: 8}],
                tree: tree1
              },
              {
                entries: [{key: 8.75, val: 10}],
                tree: tree1
              }
            ],
            tree: tree1
          }
        ],
        tree: tree1
      }
    };
    let key = [2.7], val = 3.5;
    let expected = {
      tree: {
        levels: [
          {
            service: BTreeNode,
            config: tree1
          }
        ]
      },
      root: {
        entries: [{key: 3.75, val: 5}],
        children: [
          {
            entries: [{key: 1.25, val: 1}, {key: 2.5, val: 3}],
            children: [
              {
                entries: [{key: .625, val: 0}],
                tree: tree1
              },
              {
                entries: [{key: 1.875, val: 2}],
                tree: tree1
              },
              {
                entries: [{key: 2.7, val: 3.5}, {key: 3.125, val: 4}],
                tree: tree1
              },
            ],
            tree: tree1
          },
          {
            entries: [{key: 5, val: 7}, {key: 7.5, val: 9}],
            children: [
              {
                entries: [{key: 4.375, val: 6}],
                tree: tree1
              },
              {
                entries: [{key: 6.25, val: 8}],
                tree: tree1
              },
              {
                entries: [{key: 8.75, val: 10}],
                tree: tree1
              }
            ],
            tree: tree1
          }
        ],
        tree: tree1
      }
    };
    expect(LexographicNode.add(node, key, val)).to.be.true;
    expect(node).to.deep.equal(expected);
    tree1 = {
      unique: true
    };
    node = {
      tree: {
        levels: [
          {
            service: TrieNode,
            config: tree1
          }
        ]
      },
      root: {
        tree: tree1,
        val: 9,
        children: {
          a: {
            tree: tree1,
            children: {
              l: {
                tree: tree1,
                children: {
                  p: {
                    tree: tree1,
                    children: {
                      h: {
                        tree: tree1,
                        children: {
                          a: {
                            tree: tree1,
                            val: 5,
                            children: {
                              b: {
                                tree: tree1,
                                children: {
                                  e: {
                                    tree: tree1,
                                    children: {
                                      t: {
                                        tree: tree1,
                                        val: 3,
                                        children: {}
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  e: {
                    tree: tree1,
                    children: {
                      p: {
                        tree: tree1,
                        children: {
                          h: {
                            tree: tree1,
                            val: 8,
                            children: {}
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    key = ['abra'], val = 12;
    expected = {
      tree: {
        levels: [
          {
            service: TrieNode,
            config: tree1
          }
        ]
      },
      root: {
        tree: tree1,
        val: 9,
        children: {
          a: {
            tree: tree1,
            children: {
              l: {
                tree: tree1,
                children: {
                  p: {
                    tree: tree1,
                    children: {
                      h: {
                        tree: tree1,
                        children: {
                          a: {
                            tree: tree1,
                            val: 5,
                            children: {
                              b: {
                                tree: tree1,
                                children: {
                                  e: {
                                    tree: tree1,
                                    children: {
                                      t: {
                                        tree: tree1,
                                        val: 3,
                                        children: {}
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  e: {
                    tree: tree1,
                    children: {
                      p: {
                        tree: tree1,
                        children: {
                          h: {
                            tree: tree1,
                            val: 8,
                            children: {}
                          }
                        }
                      }
                    }
                  }
                }
              },
              b: {
                tree: tree1,
                children: {
                  r: {
                    tree: tree1,
                    children: {
                      a: {
                        tree: tree1,
                        val: 12,
                        children: {}
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    expect(LexographicNode.add(node, key, val)).to.be.true;
    expect(node).to.deep.equal(expected);
    tree1 = {
      unique: true
    };
    tree2 = {
      unique: true,
      max: 3,
      compare(a, b) {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }
    };
    node = {
      tree: {
        levels: [
          {
            service: RadixTreeNode,
            config: tree1
          },
          {
            service: BTreeNode,
            config: tree2
          }
        ]
      },
      root: {
        tree: tree1,
        val: {
          tree: tree2,
          entries: [{key: 1, val: '1'}, {key: 9, val: '9'}]
        },
        children: {
          al: {
            tree: tree1,
            children: {
              pha: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 5, val: '5'}],
                  children: [
                    {
                      tree: tree2,
                      entries: [{key: 3, val: '3'},{key: 4, val: '4'}]
                    },
                    {
                      tree: tree2,
                      entries: [{key: 7, val: '7'},{key: 11, val: '11'}]
                    }
                  ]
                },
                children: {
                  bet: {
                    tree: tree1,
                    val: {
                      tree: tree2,
                      entries: [{key: 0, val: '0'}]
                    },
                    children: {}
                  }
                }
              },
              eph: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 9, val: '9'}]
                },
                children: {}
              }
            }
          }
        }
      }
    };
    key = ['alpha', 13], val = '13';
    expected = {
      tree: {
        levels: [
          {
            service: RadixTreeNode,
            config: tree1
          },
          {
            service: BTreeNode,
            config: tree2
          }
        ]
      },
      root: {
        tree: tree1,
        val: {
          tree: tree2,
          entries: [{key: 1, val: '1'}, {key: 9, val: '9'}]
        },
        children: {
          al: {
            tree: tree1,
            children: {
              pha: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 5, val: '5'}],
                  children: [
                    {
                      tree: tree2,
                      entries: [{key: 3, val: '3'},{key: 4, val: '4'}]
                    },
                    {
                      tree: tree2,
                      entries: [{key: 7, val: '7'},{key: 11, val: '11'},{key: 13, val: '13'}]
                    }
                  ]
                },
                children: {
                  bet: {
                    tree: tree1,
                    val: {
                      tree: tree2,
                      entries: [{key: 0, val: '0'}]
                    },
                    children: {}
                  }
                }
              },
              eph: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 9, val: '9'}]
                },
                children: {}
              }
            }
          }
        }
      }
    };
    expect(LexographicNode.add(node, key, val)).to.be.true;
    expect(node).to.deep.equal(expected);
    key = ['abra', 13], val = '13';
    expected = {
      tree: {
        levels: [
          {
            service: RadixTreeNode,
            config: tree1
          },
          {
            service: BTreeNode,
            config: tree2
          }
        ]
      },
      root: {
        tree: tree1,
        val: {
          tree: tree2,
          entries: [{key: 1, val: '1'}, {key: 9, val: '9'}]
        },
        children: {
          a: {
            tree: tree1,
            children: {
              bra: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 13, val: '13'}]
                },
                children: {}
              },
              l: {
                tree: tree1,
                children: {
                  pha: {
                    tree: tree1,
                    val: {
                      tree: tree2,
                      entries: [{key: 5, val: '5'}],
                      children: [
                        {
                          tree: tree2,
                          entries: [{key: 3, val: '3'},{key: 4, val: '4'}]
                        },
                        {
                          tree: tree2,
                          entries: [{key: 7, val: '7'},{key: 11, val: '11'},{key: 13, val: '13'}]
                        }
                      ]
                    },
                    children: {
                      bet: {
                        tree: tree1,
                        val: {
                          tree: tree2,
                          entries: [{key: 0, val: '0'}]
                        },
                        children: {}
                      }
                    }
                  },
                  eph: {
                    tree: tree1,
                    val: {
                      tree: tree2,
                      entries: [{key: 9, val: '9'}]
                    },
                    children: {}
                  }
                }
              }
            }
          }
        }
      }
    };
    expect(LexographicNode.add(node, key, val)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('add duplicate', function() {
    let tree1 = {
      unique: true,
      max: 3,
      compare(a, b) {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }
    }, tree2;
    let node = {
      tree: {
        levels: [
          {
            service: BTreeNode,
            config: tree1
          }
        ]
      },
      root: {
        entries: [{key: 5, val: 7}],
        children: [
          {
            entries: [{key: 1.25, val: 1}, {key: 2.5, val: 3}, {key: 3.75, val: 5}],
            children: [
              {
                entries: [{key: .625, val: 0}],
                tree: tree1
              },
              {
                entries: [{key: 1.875, val: 2}],
                tree: tree1
              },
              {
                entries: [{key: 3.125, val: 4}],
                tree: tree1
              },
              {
                entries: [{key: 4.375, val: 6}],
                tree: tree1
              }
            ],
            tree: tree1
          },
          {
            entries: [{key: 7.5, val: 9}],
            children: [
              {
                entries: [{key: 6.25, val: 8}],
                tree: tree1
              },
              {
                entries: [{key: 8.75, val: 10}],
                tree: tree1
              }
            ],
            tree: tree1
          }
        ],
        tree: tree1
      }
    };
    let key = [2.5], val = 3.5;
    let expected = {
      tree: {
        levels: [
          {
            service: BTreeNode,
            config: tree1
          }
        ]
      },
      root: {
        entries: [{key: 3.75, val: 5}],
        children: [
          {
            entries: [{key: 1.25, val: 1}, {key: 2.5, val: 3}],
            children: [
              {
                entries: [{key: .625, val: 0}],
                tree: tree1
              },
              {
                entries: [{key: 1.875, val: 2}],
                tree: tree1
              },
              {
                entries: [{key: 3.125, val: 4}],
                tree: tree1
              }
            ],
            tree: tree1
          },
          {
            entries: [{key: 5, val: 7}, {key: 7.5, val: 9}],
            children: [
              {
                entries: [{key: 4.375, val: 6}],
                tree: tree1
              },
              {
                entries: [{key: 6.25, val: 8}],
                tree: tree1
              },
              {
                entries: [{key: 8.75, val: 10}],
                tree: tree1
              }
            ],
            tree: tree1
          }
        ],
        tree: tree1
      }
    };
    //LexographicNode.add(node, key, val);
    expect(LexographicNode.add(node, key, val)).to.be.false;
    expect(node).to.deep.equal(expected);
    tree1 = {
      unique: true
    };
    node = {
      tree: {
        levels: [
          {
            service: TrieNode,
            config: tree1
          }
        ]
      },
      root: {
        tree: tree1,
        val: 9,
        children: {
          a: {
            tree: tree1,
            children: {
              l: {
                tree: tree1,
                children: {
                  p: {
                    tree: tree1,
                    children: {
                      h: {
                        tree: tree1,
                        children: {
                          a: {
                            tree: tree1,
                            val: 5,
                            children: {
                              b: {
                                tree: tree1,
                                children: {
                                  e: {
                                    tree: tree1,
                                    children: {
                                      t: {
                                        tree: tree1,
                                        val: 3,
                                        children: {}
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  e: {
                    tree: tree1,
                    children: {
                      p: {
                        tree: tree1,
                        children: {
                          h: {
                            tree: tree1,
                            val: 8,
                            children: {}
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    key = ['alphabet'], val = 12;
    expected = {
      tree: {
        levels: [
          {
            service: TrieNode,
            config: tree1
          }
        ]
      },
      root: {
        tree: tree1,
        val: 9,
        children: {
          a: {
            tree: tree1,
            children: {
              l: {
                tree: tree1,
                children: {
                  p: {
                    tree: tree1,
                    children: {
                      h: {
                        tree: tree1,
                        children: {
                          a: {
                            tree: tree1,
                            val: 5,
                            children: {
                              b: {
                                tree: tree1,
                                children: {
                                  e: {
                                    tree: tree1,
                                    children: {
                                      t: {
                                        tree: tree1,
                                        val: 3,
                                        children: {}
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  e: {
                    tree: tree1,
                    children: {
                      p: {
                        tree: tree1,
                        children: {
                          h: {
                            tree: tree1,
                            val: 8,
                            children: {}
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    expect(LexographicNode.add(node, key, val)).to.be.false;
    expect(node).to.deep.equal(expected);
    tree1 = {
      unique: true
    };
    tree2 = {
      unique: true,
      max: 3,
      compare(a, b) {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }
    };
    node = {
      tree: {
        levels: [
          {
            service: RadixTreeNode,
            config: tree1
          },
          {
            service: BTreeNode,
            config: tree2
          }
        ]
      },
      root: {
        tree: tree1,
        val: {
          tree: tree2,
          entries: [{key: 1, val: '1'}, {key: 9, val: '9'}]
        },
        children: {
          al: {
            tree: tree1,
            children: {
              pha: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 5, val: '5'}],
                  children: [
                    {
                      tree: tree2,
                      entries: [{key: 3, val: '3'},{key: 4, val: '4'}]
                    },
                    {
                      tree: tree2,
                      entries: [{key: 7, val: '7'},{key: 11, val: '11'}]
                    }
                  ]
                },
                children: {
                  bet: {
                    tree: tree1,
                    val: {
                      tree: tree2,
                      entries: [{key: 0, val: '0'}]
                    },
                    children: {}
                  }
                }
              },
              eph: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 9, val: '9'}]
                },
                children: {}
              }
            }
          }
        }
      }
    };
    key = ['aleph', 9], val = '13';
    expected = {
      tree: {
        levels: [
          {
            service: RadixTreeNode,
            config: tree1
          },
          {
            service: BTreeNode,
            config: tree2
          }
        ]
      },
      root: {
        tree: tree1,
        val: {
          tree: tree2,
          entries: [{key: 1, val: '1'}, {key: 9, val: '9'}]
        },
        children: {
          al: {
            tree: tree1,
            children: {
              pha: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 5, val: '5'}],
                  children: [
                    {
                      tree: tree2,
                      entries: [{key: 3, val: '3'},{key: 4, val: '4'}]
                    },
                    {
                      tree: tree2,
                      entries: [{key: 7, val: '7'},{key: 11, val: '11'}]
                    }
                  ]
                },
                children: {
                  bet: {
                    tree: tree1,
                    val: {
                      tree: tree2,
                      entries: [{key: 0, val: '0'}]
                    },
                    children: {}
                  }
                }
              },
              eph: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 9, val: '9'}]
                },
                children: {}
              }
            }
          }
        }
      }
    };
    expect(LexographicNode.add(node, key, val)).to.be.false;
    expect(node).to.deep.equal(expected);
  });
  if(false)
  it('add duplicate nonunique', function() {
    let tree1 = {
      unique: true,
      max: 3,
      compare(a, b) {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }
    }, tree2;
    let node = {
      tree: {
        levels: [
          {
            service: BTreeNode,
            config: tree1
          }
        ]
      },
      root: {
        entries: [{key: 5, val: 7}],
        children: [
          {
            entries: [{key: 1.25, val: 1}, {key: 2.5, val: 3}, {key: 3.75, val: 5}],
            children: [
              {
                entries: [{key: .625, val: 0}],
                tree: tree1
              },
              {
                entries: [{key: 1.875, val: 2}],
                tree: tree1
              },
              {
                entries: [{key: 3.125, val: 4}],
                tree: tree1
              },
              {
                entries: [{key: 4.375, val: 6}],
                tree: tree1
              }
            ],
            tree: tree1
          },
          {
            entries: [{key: 7.5, val: 9}],
            children: [
              {
                entries: [{key: 6.25, val: 8}],
                tree: tree1
              },
              {
                entries: [{key: 8.75, val: 10}],
                tree: tree1
              }
            ],
            tree: tree1
          }
        ],
        tree: tree1
      }
    };
    let key = [2.5], val = 3.5;
    let expected = {
      tree: {
        levels: [
          {
            service: BTreeNode,
            config: tree1
          }
        ]
      },
      root: {
        entries: [{key: 5, val: 7}],
        children: [
          {
            entries: [{key: 1.25, val: 1}, {key: 2.5, val: 3}, {key: 3.75, val: 5}],
            children: [
              {
                entries: [{key: .625, val: 0}],
                tree: tree1
              },
              {
                entries: [{key: 1.875, val: 2}],
                tree: tree1
              },
              {
                entries: [{key: 3.125, val: 4}],
                tree: tree1
              },
              {
                entries: [{key: 4.375, val: 6}],
                tree: tree1
              }
            ],
            tree: tree1
          },
          {
            entries: [{key: 7.5, val: 9}],
            children: [
              {
                entries: [{key: 6.25, val: 8}],
                tree: tree1
              },
              {
                entries: [{key: 8.75, val: 10}],
                tree: tree1
              }
            ],
            tree: tree1
          }
        ],
        tree: tree1
      }
    };
    expect(LexographicNode.add(node, key, val)).to.be.false;
    expect(node).to.deep.equal(expected);
    tree1 = {
      unique: true
    };
    node = {
      tree: {
        levels: [
          {
            service: TrieNode,
            config: tree1
          }
        ]
      },
      root: {
        tree: tree1,
        val: 9,
        children: {
          a: {
            tree: tree1,
            children: {
              l: {
                tree: tree1,
                children: {
                  p: {
                    tree: tree1,
                    children: {
                      h: {
                        tree: tree1,
                        children: {
                          a: {
                            tree: tree1,
                            val: 5,
                            children: {
                              b: {
                                tree: tree1,
                                children: {
                                  e: {
                                    tree: tree1,
                                    children: {
                                      t: {
                                        tree: tree1,
                                        val: 3,
                                        children: {}
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  e: {
                    tree: tree1,
                    children: {
                      p: {
                        tree: tree1,
                        children: {
                          h: {
                            tree: tree1,
                            val: 8,
                            children: {}
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    key = ['alphabet'], val = 12;
    expected = {
      tree: {
        levels: [
          {
            service: TrieNode,
            config: tree1
          }
        ]
      },
      root: {
        tree: tree1,
        val: 9,
        children: {
          a: {
            tree: tree1,
            children: {
              l: {
                tree: tree1,
                children: {
                  p: {
                    tree: tree1,
                    children: {
                      h: {
                        tree: tree1,
                        children: {
                          a: {
                            tree: tree1,
                            val: 5,
                            children: {
                              b: {
                                tree: tree1,
                                children: {
                                  e: {
                                    tree: tree1,
                                    children: {
                                      t: {
                                        tree: tree1,
                                        val: 3,
                                        children: {}
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  e: {
                    tree: tree1,
                    children: {
                      p: {
                        tree: tree1,
                        children: {
                          h: {
                            tree: tree1,
                            val: 8,
                            children: {}
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    expect(LexographicNode.add(node, key, val)).to.be.false;
    expect(node).to.deep.equal(expected);
    tree1 = {
      unique: true
    };
    tree2 = {
      unique: true,
      max: 3,
      compare(a, b) {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }
    };
    node = {
      tree: {
        levels: [
          {
            service: RadixTreeNode,
            config: tree1
          },
          {
            service: BTreeNode,
            config: tree2
          }
        ]
      },
      root: {
        tree: tree1,
        val: {
          tree: tree2,
          entries: [{key: 1, val: '1'}, {key: 9, val: '9'}]
        },
        children: {
          al: {
            tree: tree1,
            children: {
              pha: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 5, val: '5'}],
                  children: [
                    {
                      tree: tree2,
                      entries: [{key: 3, val: '3'},{key: 4, val: '4'}]
                    },
                    {
                      tree: tree2,
                      entries: [{key: 7, val: '7'},{key: 11, val: '11'}]
                    }
                  ]
                },
                children: {
                  bet: {
                    tree: tree1,
                    val: {
                      tree: tree2,
                      entries: [{key: 0, val: '0'}]
                    },
                    children: {}
                  }
                }
              },
              eph: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 9, val: '9'}]
                },
                children: {}
              }
            }
          }
        }
      }
    };
    key = ['aleph', 9], val = '13';
    expected = {
      tree: {
        levels: [
          {
            service: RadixTreeNode,
            config: tree1
          },
          {
            service: BTreeNode,
            config: tree2
          }
        ]
      },
      root: {
        tree: tree1,
        val: {
          tree: tree2,
          entries: [{key: 1, val: '1'}, {key: 9, val: '9'}]
        },
        children: {
          al: {
            tree: tree1,
            children: {
              pha: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 5, val: '5'}],
                  children: [
                    {
                      tree: tree2,
                      entries: [{key: 3, val: '3'},{key: 4, val: '4'}]
                    },
                    {
                      tree: tree2,
                      entries: [{key: 7, val: '7'},{key: 11, val: '11'}]
                    }
                  ]
                },
                children: {
                  bet: {
                    tree: tree1,
                    val: {
                      tree: tree2,
                      entries: [{key: 0, val: '0'}]
                    },
                    children: {}
                  }
                }
              },
              eph: {
                tree: tree1,
                val: {
                  tree: tree2,
                  entries: [{key: 9, val: '9'}]
                },
                children: {}
              }
            }
          }
        }
      }
    };
    expect(LexographicNode.add(node, key, val)).to.be.false;
    expect(node).to.deep.equal(expected);
  });
  return;
  it('remove dne', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      compare(a, b) {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }
    };
    const node = {
      entries: [5],
      children: [
        {
          entries: [1.25, 2.5, 3.75],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            },
            {
              entries: [2.8125, 3.125, 3.4375],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [6.25, 7.5, 8.75],
          children: [
            {
              entries: [5.625],
              tree
            },
            {
              entries: [6.875],
              tree
            },
            {
              entries: [8.126],
              tree
            },
            {
              entries: [9.375],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 3, expected = {
      entries: [5],
      children: [
        {
          entries: [1.25, 2.5, 3.75],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            },
            {
              entries: [2.8125, 3.125, 3.4375],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [6.25, 7.5, 8.75],
          children: [
            {
              entries: [5.625],
              tree
            },
            {
              entries: [6.875],
              tree
            },
            {
              entries: [8.126],
              tree
            },
            {
              entries: [9.375],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(LexographicNode.remove(node, key)).to.be.false;
    expect(node).to.deep.equal(expected);
  });
  it('remove', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      compare(a, b) {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }
    };
    const node = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15],
              tree
            },
            {
              entries: [24, 25, 23],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 25, expected = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15],
              tree
            },
            {
              entries: [24, 23],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(LexographicNode.remove(node, key)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('toJSON', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      compare(a, b) {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }
    };
    const node = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15],
              tree
            },
            {
              entries: [25],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    const expected = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          children: [
            {
              entries: [5]
            },
            {
              entries: [15]
            },
            {
              entries: [25]
            },
            {
              entries: [35]
            }
          ]
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45]
            },
            {
              entries: [55]
            },
            {
              entries: [65]
            },
            {
              entries: [75]
            }
          ]
        }
      ]
    };
    setupNode(node);
    setupNode(expected);
    expect(LexographicNode.toJSON(node,)).to.deep.equal(expected);
  });
});

describe('LexographicSet', function() {
  let LexographicSet;
  beforeEach(function() {
    LexographicSet = oaStruct.get('LexographicSet');
  });
  it('is not null', function() {
    expect(LexographicSet).to.not.be.null;
  });
});

});
const oaStruct = require('./oa_struct.js');

/* web-start */

function LexographicNodeGen(_) {
  class LexographicNode {
    /* TODO */
    static isValid(node, tree) {
      if (!tree) {
        if (node.tree == undefined) return false;
        if (node.tree.unique !== true && node.tree.unique !== false) return false;
      }
      else {
        node.tree = tree;
      }
      if (!node.tree.unique && !_.isArray(node.vals)) return false;
      if (node.children == undefined) return false;
      for (const [cc, child] of Object.entries(node.children)) {
        if (!LexographicNode.isValid(child, tree)) return false;
      }
      return true;
    }
    /* TODO */
    static validate(node, tree, prefix = '') {
      if (!tree) {
        if (node.tree == undefined)
          throw new Error(`node[${prefix}] must reference parent tree`);
        if (node.tree.unique !== true && node.tree.unique !== false)
          throw new Error(`node[${prefix}].tree.unique must be truthy`);
      }
      else {
        node.tree = tree;
      }
      if (!node.tree.unique && !_.isArray(node.vals))
        throw new Error(`node[${prefix}].vals must be an array`);
      if (node.children == undefined)
        throw new Error(`node[${prefix}].children must not be null`);
      for (const [cc, child] of Object.entries(node.children)) {
        LexographicNode.validate(child, tree, prefix + cc);
      }
    }
    static size(node) {
      function levelCount(cur, i) {
        const { service } = node.tree.levels[i];
        if (i == node.tree.levels.length - 1) {
          return service.size(cur);
        }
        else {
          let count = 0;
          for (let e of service.inOrderGenerator(cur)) {
            count += levelCount(e.val, i + 1);
          }
          return count;
        }
      }
      return levelCount(node.root, 0);
    }
    static at(node, key) {
      let cur = node.root;
      node.tree.levels.forEach(({ service, config }, i) => {
        if (cur == undefined) return;
        cur = service.at(cur, key[i]);
      });
      return cur;
    }
    static add(node, key, val) {
      let cur = node.root;
      node.tree.levels.forEach(({ service, config }, i) => {
        if (i < node.tree.levels.length - 1) {
          let next = service.at(cur, key[i]);
          if (!next) {
            const level = node.tree.levels[i + 1];
            next = level.service.init(level.config);
            service.add(cur, key[i], next);
          }
          cur = next;
        }
        else
          cur = service.add(cur, key[i], val);
      });
      return cur;
    }
    /* TODO */
    static remove(node, key) {
      if (node.children && node.entries.length <= node.tree.min) {
        let { sum, /*max, i*/ } = node.children.reduce((a, c, i) => {
          let n = c.entries.length;
          a.sum += n;
          if (n > a.max) {
            a.max = n;
            a.i = i;
          }
          return a;
        }, { sum: node.entries.length, max: 0, i: 0 });
        if (sum <= node.tree.max)
          LexographicNode.mergeRoot(node);
        //else
        //LexographicNode.split
      }
      let i = 0;
      while (i < node.entries.length && node.tree.compare(node.entries[i].key, key) < 0) i++;
      if (i < node.entries.length && node.tree.compare(node.entries[i].key, key) == 0) {
        if (node.children) {
          if (node.children[i].entries.length == node.tree.min) {
            if (node.children[i + 1].entries.length == node.tree.min) {
              LexographicNode.merge(node, i);
              return LexographicNode.remove(node.children[i], key);
            }
            node.entries[i] = LexographicNode.popFirst(node.children[i + 1]);
          }
          else {
            node.entries[i] = LexographicNode.popLast(node.children[i]);
          }
        }
        else {
          node.entries.splice(i, 1);
        }
        return true;
      }
      if (node.children) {
        let child = node.children[i];
        if (child.entries.length == node.tree.min) {
          if (i == 0 && node.children[i + 1].entries.length > node.tree.min) LexographicNode.shiftDown(node, i + 1);
          else if (i > 0 && node.children[i - 1].entries.length > node.tree.min) LexographicNode.shiftUp(node, i - 1);
          else if (i == 0) {
            LexographicNode.merge(node, i);
            child = node.children[i];
          }
          else {
            --i;
            LexographicNode.merge(node, i);
            child = node.children[i];
          }
        }
        return LexographicNode.remove(child, key);
      }
      else {
        return false;
      }
    }
    /* TODO */
    static toJSON(node) {
      let { entries, children } = node;
      let json = { entries };
      if (node.children) json.children = children.map(c => LexographicNode.toJSON(c));
      return json;
    }
    static * inOrderGenerator(node) {
      function* iterate(cur, i, key) {
        let iterationCount = 0;
        const { service } = node.tree.levels[i];
        if (i == node.tree.levels.length - 1) {
          for (let e of service.inOrderGenerator(cur)) {
            iterationCount++;
            yield { key: key.concat(e.key), val: e.val };
          }
        }
        else {
          for (let sub of service.inOrderGenerator(cur)) {
            for (let e of iterate(sub.val, i + 1, key.concat(sub.key))) {
              iterationCount++;
              yield e;
            }
          }
        }
        return iterationCount;
      }
      let iterationCount = 0;
      for (let e of iterate(node.root, 0, [])) {
        iterationCount++;
        yield e;
      }
      return iterationCount;
    }
  }

  return LexographicNode;
}
oaStruct.Register('LexographicNode', LexographicNodeGen, []);

function LexographicSetGen(LexographicNode) {
  class LexographicSet {
    #max;
    #min;
    #unique;
    #comparator;
    #root;
    constructor(max, min, unique, comparator, root) {
      this.#max = max;
      this.#min = min;
      this.#unique = unique;
      this.#comparator = comparator;
      if (root) LexographicNode.validate(root);
      this.#root = root ? root : {
        tree: this,
        entries: []
      };
    }
    get max() { return this.#max; }
    get min() { return this.#min; }
    get unique() { return this.#unique; }
    compare(a, b) { return this.#comparator(a, b); }
    size() {
      return LexographicNode.size(this.#root);
    }
    at(key) {
      return LexographicNode.at(this.#root, key);
    }
    add(key, val) {
      return LexographicNode.add(this.#root, key, val);
    }
    remove(key) {
      return LexographicNode.remove(this.#root, key);
    }
    toJSON() {
      return LexographicNode.toJSON(this.#root);
    }
  }

  return LexographicSet;
}
oaStruct.Register('LexographicSet', LexographicSetGen, ['LexographicNode']);

/* web-end */

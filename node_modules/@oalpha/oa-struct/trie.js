const oaStruct = require('./oa_struct.js');

/* web-start */

function TrieNodeGen(_) {
  class TrieNode {
    static isValid(node, tree) {
      if (!tree) {
        if (node.tree == undefined) return false;
        if (node.tree.unique !== true && node.tree.unique !== false) return false;
      }
      else {
        node.tree = tree;
      }
      if (!node.tree.unique && !_.isArray(node.vals)) return false;
      if (node.children == undefined) return false;
      for (const [cc, child] of Object.entries(node.children)) {
        if (!TrieNode.isValid(child, tree)) return false;
      }
      return true;
    }
    static validate(node, tree, prefix = '') {
      if (!tree) {
        if (node.tree == undefined)
          throw new Error(`node[${prefix}] must reference parent tree`);
        if (node.tree.unique !== true && node.tree.unique !== false)
          throw new Error(`node[${prefix}].tree.unique must be truthy`);
      }
      else {
        node.tree = tree;
      }
      if (!node.tree.unique && !_.isArray(node.vals))
        throw new Error(`node[${prefix}].vals must be an array`);
      if (node.children == undefined)
        throw new Error(`node[${prefix}].children must not be null`);
      for (const [cc, child] of Object.entries(node.children)) {
        TrieNode.validate(child, tree, prefix + cc);
      }
    }
    static init(tree) {
      let node = {
        tree,
        children: {}
      };
      if (!tree.unique)
        node.vals = [];
      return node;
    }
    static size(node) {
      let s = node.tree.unique ? (node.val == undefined ? 0 : 1) : node.vals.length;
      if (node.children) {
        for (const child of Object.entries(node.children))
          s += TrieNode.size(child[1]);
      }
      return s;
    }
    static at(node, key) {
      if (key.length == 0) {
        if (node.tree.unique)
          return node.val;
        else
          return node.vals.map(v => v);
      }
      else {
        var cc = key[0];
        key = key.substr(1);
        var child = node.children[cc];
        if (!child) {
          return;
        }
        return TrieNode.at(child, key);
      }
    }
    static add(node, key, val) {
      if (key.length == 0) {
        if (node.tree.unique) {
          if (node.val != undefined) return false;
          node.val = val;
        }
        else
          node.vals.push(val);
        return true;
      }
      else {
        var cc = key[0];
        key = key.substr(1);
        var child = node.children[cc];
        if (!child) {
          child = node.children[cc] = {
            tree: node.tree,
            children: {}
          };
          if (!node.tree.unique) child.vals = [];
        }
        return TrieNode.add(child, key, val);
      }
    }
    static remove(node, key) {
      if (key.length == 0) {
        if (node.tree.unique) {
          if (node.val == undefined) return false;
          delete node.val;
        }
        else
          node.vals = [];
        return true;
      }
      else {
        var cc = key[0];
        key = key.substr(1);
        var child = node.children[cc];
        if (!child) return false;
        let r = TrieNode.remove(child, key);
        if (r && TrieNode.size(child) == 0)
          delete node.children[cc];
        return r;
      }
    }
    static toJSON(node) {
      var json = { children: {} };
      var keys = Object.keys(node.children);
      keys.sort();
      keys.forEach(cc => {
        json.children[cc] = TrieNode.toJSON(node.children[cc]);
      });
      if (node.tree.unique) {
        if (node.val != undefined) json.val = node.val;
      }
      else if (node.vals.length)
        json.vals = node.vals.map(v => v);
      return json;
    }
    static *inOrderGenerator(node, prefix = '') {
      let iterationCount = 0;
      if (node.tree.unique) {
        if (node.val) {
          iterationCount++;
          yield { key: prefix, val: node.val };
        }
      }
      else {
        for (let i = 0; i < node.vals.length; i++) {
          iterationCount++;
          yield { key: prefix, val: node.vals[i] };
        }
      }
      let keys = Object.keys(node.children);
      keys.sort();
      for (const cc of keys) {
        let child = node.children[cc];
        for (let e of TrieNode.inOrderGenerator(child, prefix + cc)) {
          iterationCount++;
          yield e;
        }
      }
      return iterationCount;
    }
  }

  return TrieNode;
}
oaStruct.Register('trieNode', TrieNodeGen, ['_']);

function TrieGen(TrieNode) {
  class Trie {
    #unique;
    #root;
    constructor(unique, root) {
      this.#unique = unique;
      if (root) TrieNode.validate(root, this);
      this.#root = root ? root : {
        tree: this,
        children: {}
      };
      if (!unique) this.#root.vals = [];
    }
    get unique() { return this.#unique; }
    size() {
      return TrieNode.size(this.#root);
    }
    at(key) {
      return TrieNode.at(this.#root, key);
    }
    add(key, val) {
      return TrieNode.add(this.#root, key, val);
    }
    remove(key) {
      return TrieNode.remove(this.#root, key);
    }
    toJSON() {
      return TrieNode.toJSON(this.#root);
    }
  }

  return Trie;
}
oaStruct.Register('trie', TrieGen, ['trieNode']);

/*
function TieredTrieDefaultConfigGen(TrieNode) {
  var defaultConfig = {
    module: oaStruct,
    tree: 'tieredTrie',
    createTree(depth, prefix, path, max, config) {
      return oaStruct.instantiate('tieredTrie', depth, prefix, path, max, config);
    },
    node: 'tieredTrieNode',
    createNode(tree, c, level, parent, config) {
      return oaStruct.instantiate('tieredTrieNode', tree, c, level, parent, config);
    },
    map: 'map',
    createMap() {
      return new Map();
    }
  };

  return defaultConfig;
}
oaStruct.RegisterValue('tieredTrieDefaultConfig', TieredTrieDefaultConfigGen, []);

function TieredTrieNodeGen(defaultConfig) {
  function TieredTrieNode(tree, c, level, parent, config = defaultConfig) {
    var This = this;
    var children;
    var leaves = [];
    var subtree;
    var map, mapIndex;
    if (level == tree.maxdepth) {
      map = config.createMap(word(), path(), config);
      mapIndex = config.maps.add(map);
    }
    else if (level == tree.depth) subtree = config.createTree(tree.depth, word(), path(), tree.maxdepth - level, config);
    else children = {};

    function word() {
      if (parent != null) {
        return parent.word() + c;
      }
      return tree.prefix + c;
    }

    function path() {
      var p;
      if (parent != null) {
        p = parent.path();
      }
      else {
        p = tree.path;
        p.push('');
      }
      p[p.length - 1] += c;
      return p;
    }

    function add(str, val) {
      if (str.length == 0) {
        leaves.push(val);
      }
      else if (level == tree.maxdepth) {
        config.maps.load(mapIndex);
        var arr = map.get(str);
        if (!arr) { arr = [];
          map.set(str, arr); }
        arr.push(val);
      }
      else if (level == tree.depth) {
        subtree.add(str, val);
      }
      else {
        var cc = str[0];
        str = str.substr(1);
        var child = children[cc];
        if (!child) child = children[cc] = new TieredTrieNode(tree, cc, level + 1, This, config);
        //if (!child) child = children[cc] = config.createNode(tree, cc, level + 1, This, config);
        child.add(str, val);
      }
    }

    function forEach(f) {
      if (level == tree.depth) return;
      var keys = Object.keys(children);
      keys.sort();
      var w = word();
      keys.forEach((cc) => {
        f.call(null, cc, children[cc], w + cc);
      });
    }

    function forEachNode(f, pre) {
      var w = word();
      if(level == tree.maxdepth) config.maps.load(mapIndex);
      if (pre) f.call(null, this, c, w, leaves, map);
      if (level == tree.maxdepth) {}
      else if (level == tree.depth) {
        subtree.forEachNode(f, pre);
      }
      else {
        var keys = Object.keys(children);
        keys.sort();
        keys.forEach((cc) => {
          children[cc].forEachNode(f, pre);
        });
      }
      if (!pre) f.call(null, this, c, w, leaves, map);
    }

    function forEachLeaf(f) {
      var w = word();
      if (leaves.length > 0) f.call(null, leaves, c, w);
      if (level == tree.maxdepth) {
        config.maps.load(mapIndex);
        var dkeys = [ ...map.keys() ];
        dkeys.sort();
        dkeys.forEach((str) => {
          f.call(null, map.get(str), str, w + str);
        });
      }
      else if (level == tree.depth) {
        subtree.forEachLeaf(f);
      }
      else {
        var keys = Object.keys(children);
        keys.sort();
        keys.forEach((cc) => {
          children[cc].forEachLeaf(f);
        });
      }
    }

    function toJSON(singleTier) {
      var json;
      if (level == tree.maxdepth) {
        config.maps.load(mapIndex);
        json = Object.fromEntries(map);
      }
      else if (level == tree.depth) {
        json = singleTier ? {} : subtree.toJSON();
      }
      else {
        json = {};
        var keys = Object.keys(children);
        keys.sort();
        keys.forEach(key => {
          json[key] = children[key].toJSON(singleTier);
        });
      }
      if (leaves.length)
        json[''] = leaves.map(v => v);
      return json;
    }

    Object.defineProperties(This, {
      c: { get: () => c },
      parent: { get: () => parent },
      children: { get: () => children },
      leaves: { get: () => leaves },
      word: { get: () => word },
      path: { get: () => path },
      add: { get: () => add },
      forEach: { get: () => forEach },
      forEachNode: { get: () => forEachNode },
      forEachLeaf: { get: () => forEachLeaf },
      toJSON: { get: () => toJSON },
    });
  }

  return TieredTrieNode;
}
oaStruct.RegisterConstructor('tieredTrieNode', [], TieredTrieNodeGen, ['tieredTrieDefaultConfig']);

function TieredTrieGen(defaultConfig) {
  function TieredTrie(depth, prefix = '', path = [], max = -1, config = defaultConfig) {
    if(!config.createTree) {
      config.createTree = function(depth, prefix, max, config) {
        new TieredTrie(depth, prefix, max, config);
      };
    }
    if(!config.createNode) {
      config.createNode = function(tree, c, level, parent, config) {
        return config.module.instantiate(config.node, tree, c, level, parent, config);
      };
    }
    if(!config.createMap) {
      config.createMap = function() {
        config.module.instantiate(config.map);
      };
    }
    if(!config.maps) {
      config.maps = oaStruct.instantiate('trivialResourceSet');
    }
    var root = config.createNode(this, '', 0, undefined, config);

    Object.defineProperties(this, {
      depth: { get: () => depth },
      maxdepth: { get: () => max },
      prefix: { get: () => prefix },
      path: { get: () => path },
      add: { get: () => root.add },
      //forEach: { get: () => forEach },
      forEachNode: { get: () => root.forEachNode },
      forEachLeaf: { get: () => root.forEachLeaf },
      toJSON: { get: () => root.toJSON },
    });
  }

  return TieredTrie;
}
oaStruct.RegisterConstructor('tieredTrie', [], TieredTrieGen, ['tieredTrieDefaultConfig']);
//*/

function RadixTreeNodeGen(_) {
  class RadixTreeNode {
    static isValid(node, tree) {
      if (!tree) {
        if (node.tree == undefined) return false;
        if (node.tree.unique !== true && node.tree.unique !== false) return false;
      }
      else {
        node.tree = tree;
      }
      if (!node.tree.unique && !_.isArray(node.vals)) return false;
      if (node.children == undefined) return false;
      for (const [cc, child] of Object.entries(node.children)) {
        if (!RadixTreeNode.isValid(child, tree)) return false;
      }
      return true;
    }
    static validate(node, tree, prefix = '') {
      if (!tree) {
        if (node.tree == undefined)
          throw new Error(`node[${prefix}] must reference parent tree`);
        if (node.tree.unique !== true && node.tree.unique !== false)
          throw new Error(`node[${prefix}].tree.unique must be truthy`);
      }
      else {
        node.tree = tree;
      }
      if (!node.tree.unique && !_.isArray(node.vals))
        throw new Error(`node[${prefix}].vals must be an array`);
      if (node.children == undefined)
        throw new Error(`node[${prefix}].children must not be null`);
      for (const [cc, child] of Object.entries(node.children)) {
        RadixTreeNode.validate(child, tree, prefix + cc);
      }
    }
    static init(tree) {
      let node = {
        tree,
        children: {}
      };
      if (!tree.unique)
        node.vals = [];
      return node;
    }
    static size(node) {
      let s = node.tree.unique ? (node.val == undefined ? 0 : 1) : node.vals.length;
      if (node.children) {
        for (const child of Object.entries(node.children))
          s += RadixTreeNode.size(child[1]);
      }
      return s;
    }
    static at(node, key) {
      if (key.length == 0) {
        if (node.tree.unique)
          return node.val;
        else
          return node.vals.map(v => v);
      }
      else {
        for (const [pre, child] of Object.entries(node.children)) {
          const sanitized = pre.replace(/\(/, '\\(').replace(/\)/, '\\)');
          let exp = new RegExp(`^${sanitized}(.*)$`);
          let m = key.match(exp);
          if (m) {
            return RadixTreeNode.at(child, m[1]);
          }
        }
      }
    }
    static add(node, key, val) {
      if (key.length == 0) {
        if (node.tree.unique) {
          if (node.val != undefined) return false;
          node.val = val;
        }
        else
          node.vals.push(val);
        return true;
      }
      else {
        for (const [pre, child] of Object.entries(node.children)) {
          const sanitized = pre.replace(/\(/, '\\(').replace(/\)/, '\\)');
          let exp = new RegExp(`^${sanitized}(.*)$`);
          let m = key.match(exp);
          if (m) {
            return RadixTreeNode.add(child, m[1], val);
          }
          let i = 0,
            c = '';
          while (pre[i] == key[i]) {
            c += key[i++];
          }
          if (i > 0) {
            let r = pre.substr(i);
            let parent = {
              tree: node.tree,
              children: {
                [r]: child
              }
            };
            if (!node.tree.unique) parent.vals = [];
            delete node.children[pre];
            node.children[c] = parent;
            return RadixTreeNode.add(parent, key.substr(i), val);
          }
        }
        node.children[key] = {
          tree: node.tree,
          children: {}
        };
        if (!node.tree.unique) node.children[key].vals = [];
        return RadixTreeNode.add(node.children[key], '', val);
      }
    }
    static remove(node, key) {
      if (key.length == 0) {
        if (node.tree.unique) {
          if (node.val == undefined) return false;
          delete node.val;
        }
        else
          node.vals = [];
        return true;
      }
      else {
        for (const [pre, child] of Object.entries(node.children)) {
          let m = key.match(new RegExp(`^${pre}(.*)$`));
          if (m) {
            let r = RadixTreeNode.remove(child, m[1]);
            if (r && RadixTreeNode.size(child) == 0)
              delete node.children[pre];
            return r;
          }
        }
        return false;
      }
    }
    static toJSON(node) {
      var json = { children: {} };
      var keys = Object.keys(node.children);
      keys.sort();
      keys.forEach(cc => {
        json.children[cc] = RadixTreeNode.toJSON(node.children[cc]);
      });
      if (node.tree.unique) {
        if (node.val != undefined) json.val = node.val;
      }
      else if (node.vals.length)
        json.vals = node.vals.map(v => v);
      return json;
    }
    static *inOrderGenerator(node, prefix = '') {
      let iterationCount = 0;
      if (node.tree.unique) {
        if (node.val) {
          iterationCount++;
          yield { key: prefix, val: node.val };
        }
      }
      else {
        for (let i = 0; i < node.vals.length; i++) {
          iterationCount++;
          yield { key: prefix, val: node.vals[i] };
        }
      }
      let keys = Object.keys(node.children);
      keys.sort();
      for (const cc of keys) {
        let child = node.children[cc];
        for (let e of RadixTreeNode.inOrderGenerator(child, prefix + cc)) {
          iterationCount++;
          yield e;
        }
      }
      return iterationCount;
    }
  }

  return RadixTreeNode;
}
oaStruct.Register('radixTreeNode', RadixTreeNodeGen, ['_']);

function RadixTreeGen(RadixTreeNode) {
  class RadixTree {
    #unique;
    #root;
    constructor(unique, root) {
      this.#unique = unique;
      if (root) RadixTreeNode.validate(root, this);
      this.#root = root ? root : {
        tree: this,
        children: {}
      };
      if (!unique) this.#root.vals = [];
    }
    get unique() { return this.#unique; }
    size() {
      return RadixTreeNode.size(this.#root);
    }
    at(key) {
      return RadixTreeNode.at(this.#root, key);
    }
    add(key, val) {
      return RadixTreeNode.add(this.#root, key, val);
    }
    remove(key) {
      return RadixTreeNode.remove(this.#root, key);
    }
    toJSON() {
      return RadixTreeNode.toJSON(this.#root);
    }
  }

  return RadixTree;
}
oaStruct.Register('radixTree', RadixTreeGen, ['radixTreeNode']);

/* web-end */

const oaStruct = require('./oa_struct.js');

/* web-start */

function MDArrayGen(_) {
  class MDArray {
    static MakeRectangular(size, opt) {
      let {leaf, internal} = opt || {};
      let d = size.length;
      function mk(l, indices) {
        let a = d - l - 1;
        let arr = _.times(size[a], i => {
          let nindices = indices.concat(i);
          let space;
          if(l == d - 1)
            space = leaf ? leaf.call(null, l, i,nindices) : null;
          else {
            space = mk(l + 1, nindices);
            Object.assign(space, {
              indices: nindices,
              level: l,
              index: i
            });
          }
          if(internal)
            internal.call(null, space, l, i, nindices);
          return space;
        });
        arr.forEach(space => {
          if(l < d - 1 && space != undefined)
            space.parent = arr;
        });
        return arr;
      }
      return mk(0, []);
    }
    
    static IterateRectangular(arr, {size, order, min, max}, f, ctx, l = 0, indices = []) {
      if(order == undefined) order = size.length;
      let a = order - l - 1;
      let mn = min ? min[a] : 0;
      let mx = max ? max[a] : arr.length - 1;
      let end = false;
      for(let i = mn; i <= mx && !end; i++) {
        if(l == order - 1) {
          end = f.call(ctx, arr[i], indices.concat(i));
        }
        else {
          let nindices = indices.concat(i);
          end = MDArray.IterateRectangular(
            arr[i], {size, order, min, max},
            f, ctx,
            l + 1, nindices
          );
        }
      }
      return end;
    }
    static *RectangularIterator(arr, {size, order, min, max}, l = 0) {
      let iterationCount = 0;
      if(order == undefined) order = size.length;
      let a = order - l - 1;
      let mn = min ? min[a] : 0;
      let mx = max ? max[a] : arr.length - 1;
      if(l == order - 1) {
        for(let i = mn; i <= mx; i++) {
          iterationCount++;
          yield arr[i];
        }
      }
      for(let i = mn; i <= mx; i++) {
        for(let e of MDArray.RectangularIterator(
          arr[i], {size, order, min, max},
          l + 1
        )) {
          iterationCount++;
          yield e;
        }
      }
      return iterationCount;
    }
    static ForEachRectangular(arr, spec, f, ctx, l = 0, indices = []) {
      MDArray.IterateRectangular(arr, spec, (e, is) => {
        f.call(ctx, e, is);
        return false;
      });
    }
    static MapRectangular(arr, spec, f, ctx) {}
    static ReduceRectangular(arr, spec, f, ctx, start) {
      let acc = start;
      MDArray.ForEachRectangular(arr, spec, (e, is) => {
        acc = f.call(ctx, acc, e, is);
      });
      return acc;
    }
    static SomeRectangular(arr, spec, f, ctx) {
      return MDArray.IterateRectangular(arr, spec, (e, is) => {
        return f.call(ctx, e, is);
      });
    }
    static EveryRectangular(arr, spec, f, ctx) {
      return !MDArray.IterateRectangular(arr, spec, (e, is) => {
        return !f.call(ctx, e, is);
      });
    }
  }
  
  return MDArray;
}

oaStruct.Register('mdArray', MDArrayGen, ['_']);

/* web-end */

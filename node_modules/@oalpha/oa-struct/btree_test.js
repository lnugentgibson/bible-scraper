const chai = require('chai');
const chaiIterator = require('chai-iterator');
chai.use(chaiIterator);
const {
  expect
} = chai;
chai.should();
const sinon = require('sinon');

const oaStruct = require('./oa_struct.js');
require('./btree.js');

describe('btree.js', function() {

describe('BTreeNode', function() {
  let BTreeNode, setupNode;
  beforeEach(function() {
    BTreeNode = oaStruct.get('btreeNode');
    setupNode = (node/*, tree*/, unique = true) => {
      //node.tree = tree;
      node.entries.forEach((e, i) => {
        if(unique)
          node.entries[i] = {
            key: e,
            val: '' + e
          };
        else
          node.entries[i] = {
            key: e,
            vals: ['' + e]
          };
      });
      if(node.children)
        node.children.forEach(child => {
          setupNode(child/*, tree*/, unique);
        });
    };
  });
  it('is not null', function() {
    expect(BTreeNode).to.not.be.null;
  });
  it('size', function() {
    const tree = {
      unique: true,
      max: 3,
      comparator: 'operator'
    };
    let node = {
      entries: [5, 7.5],
      tree
    };
    setupNode(node);
    expect(BTreeNode.size(node)).to.equal(2);
    node = {
      entries: [5],
      children: [
        {
          entries: [3.75],
          tree
        },
        {
          entries: [7.5],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    expect(BTreeNode.size(node)).to.equal(3);
    node = {
      entries: [5],
      children: [
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              tree
            },
            {
              entries: [8.75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    expect(BTreeNode.size(node)).to.equal(7);
    node = {
      entries: [5],
      children: [
        {
          entries: [1.25, 2.5, 3.75],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            },
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              tree
            },
            {
              entries: [8.75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    expect(BTreeNode.size(node)).to.equal(11);
  });
  it('get', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15],
              tree
            },
            {
              entries: [25],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    expect(BTreeNode.at(node, 40)).to.equal('40');
    expect(BTreeNode.at(node, 10)).to.equal('10');
    expect(BTreeNode.at(node, 30)).to.equal('30');
    expect(BTreeNode.at(node, 60)).to.equal('60');
    expect(BTreeNode.at(node, 5)).to.equal('5');
    expect(BTreeNode.at(node, 25)).to.equal('25');
    expect(BTreeNode.at(node, 75)).to.equal('75');
  });
  it('iterators', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15],
              tree
            },
            {
              entries: [25],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    //BTreeNode.inOrderIterator(node).should.deep.iterate.over([5,10,15,20,25,30,35,40,45,50,55,60,65,70,75].map(v => ({key: v, val: '' + v})));
    BTreeNode.inOrderGenerator(node).should.deep.iterate.over([5,10,15,20,25,30,35,40,45,50,55,60,65,70,75].map(v => ({key: v, val: '' + v})));
    BTreeNode.preOrderGenerator(node).should.deep.iterate.over([40,10,20,30,5,15,25,35,50,60,70,45,55,65,75].map(v => ({key: v, val: '' + v})));
    BTreeNode.postOrderGenerator(node).should.deep.iterate.over([5,15,25,35,10,20,30,45,55,65,75,50,60,70,40].map(v => ({key: v, val: '' + v})));
  });
  it('split', function() {
    const tree = {
      unique: true,
      max: 3,
      comparator: 'operator'
    };
    const node = {
      entries: [5],
      children: [
        {
          entries: [1.25, 2.5, 3.75],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            },
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              tree
            },
            {
              entries: [8.75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, expected = {
      entries: [2.5, 5],
      children: [
        {
          entries: [1.25],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              tree
            },
            {
              entries: [8.75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    BTreeNode.split(node, 0);
    expect(node).to.deep.equal(expected);
  });
  it('splitRoot', function() {
    const tree = {
      unique: true,
      max: 3,
      comparator: 'operator'
    };
    const node = {
      entries: [2.5, 5, 7.5],
      children: [
        {
          entries: [1.25],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [6.25],
          children: [
            {
              entries: [5.625],
              tree
            },
            {
              entries: [6.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [8.75],
          children: [
            {
              entries: [8.125],
              tree
            },
            {
              entries: [9.375],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, expected = {
      entries: [5],
      children: [
        {
          entries: [2.5],
          children: [
            {
              entries: [1.25],
              children: [
                {
                  entries: [.625],
                  tree
                },
                {
                  entries: [1.875],
                  tree
                }
              ],
              tree
            },
            {
              entries: [3.75],
              children: [
                {
                  entries: [3.125],
                  tree
                },
                {
                  entries: [4.375],
                  tree
                }
              ],
              tree
            },
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              children: [
                {
                  entries: [5.625],
                  tree
                },
                {
                  entries: [6.875],
                  tree
                }
              ],
              tree
            },
            {
              entries: [8.75],
              children: [
                {
                  entries: [8.125],
                  tree
                },
                {
                  entries: [9.375],
                  tree
                }
              ],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    BTreeNode.splitRoot(node);
    expect(node.entries).to.deep.equal(expected.entries);
    expect(node).to.deep.equal(expected);
  });
  it('merge', function() {
    const node = {
      entries: [2.5, 5],
      children: [
        {
          entries: [1.25],
          children: [
            {
              entries: [.625]
            },
            {
              entries: [1.875]
            }
          ]
        },
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125]
            },
            {
              entries: [4.375]
            }
          ]
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25]
            },
            {
              entries: [8.75]
            }
          ]
        }
      ]
    }, expected = {
      entries: [5],
      children: [
        {
          entries: [1.25, 2.5, 3.75],
          children: [
            {
              entries: [.625]
            },
            {
              entries: [1.875]
            },
            {
              entries: [3.125]
            },
            {
              entries: [4.375]
            }
          ]
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25]
            },
            {
              entries: [8.75]
            }
          ]
        }
      ]
    };
    setupNode(node);
    setupNode(expected);
    BTreeNode.merge(node, 0);
    expect(node).to.deep.equal(expected);
  });
  it('mergeRoot', function() {
    const tree = {
      unique: true,
      max: 3,
      comparator: 'operator'
    };
    const node = {
      entries: [5],
      children: [
        {
          entries: [2.5],
          children: [
            {
              entries: [1.25],
              children: [
                {
                  entries: [.625],
                  tree
                },
                {
                  entries: [1.875],
                  tree
                }
              ],
              tree
            },
            {
              entries: [3.75],
              children: [
                {
                  entries: [3.125],
                  tree
                },
                {
                  entries: [4.375],
                  tree
                }
              ],
              tree
            },
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              children: [
                {
                  entries: [5.625],
                  tree
                },
                {
                  entries: [6.875],
                  tree
                }
              ],
              tree
            },
            {
              entries: [8.75],
              children: [
                {
                  entries: [8.125],
                  tree
                },
                {
                  entries: [9.375],
                  tree
                }
              ],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, expected = {
      entries: [2.5, 5, 7.5],
      children: [
        {
          entries: [1.25],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [6.25],
          children: [
            {
              entries: [5.625],
              tree
            },
            {
              entries: [6.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [8.75],
          children: [
            {
              entries: [8.125],
              tree
            },
            {
              entries: [9.375],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    BTreeNode.mergeRoot(node);
    expect(node.entries).to.deep.equal(expected.entries);
    expect(node.children.length).to.equal(expected.children.length);
    expect(node).to.deep.equal(expected);
  });
  it('shiftUp', function() {
    const node = {
      entries: [5],
      children: [
        {
          entries: [1.6, 3.3],
          children: [
            {
              entries: [.83]
            },
            {
              entries: [2.5]
            },
            {
              entries: [4.16]
            }
          ]
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25]
            },
            {
              entries: [8.75]
            }
          ]
        }
      ]
    }, expected = {
      entries: [3.3],
      children: [
        {
          entries: [1.6],
          children: [
            {
              entries: [.83]
            },
            {
              entries: [2.5]
            }
          ]
        },
        {
          entries: [5, 7.5],
          children: [
            {
              entries: [4.16]
            },
            {
              entries: [6.25]
            },
            {
              entries: [8.75]
            }
          ]
        }
      ]
    };
    setupNode(node);
    setupNode(expected);
    BTreeNode.shiftUp(node, 0);
    expect(node.entries.length).to.equal(1);
    expect(node.children[0].entries.length).to.equal(1);
    expect(node.children[1].entries.length).to.equal(2);
    expect(node.children.length).to.equal(2);
    expect(node.children[0].children.length).to.equal(2);
    expect(node.children[1].children.length).to.equal(3);
    expect(node).to.deep.equal(expected);
  });
  it('shiftDown', function() {
    const node = {
      entries: [3.3],
      children: [
        {
          entries: [1.6],
          children: [
            {
              entries: [.83]
            },
            {
              entries: [2.5]
            }
          ]
        },
        {
          entries: [5, 7.5],
          children: [
            {
              entries: [4.16]
            },
            {
              entries: [6.25]
            },
            {
              entries: [8.75]
            }
          ]
        }
      ]
    }, expected = {
      entries: [5],
      children: [
        {
          entries: [1.6, 3.3],
          children: [
            {
              entries: [.83]
            },
            {
              entries: [2.5]
            },
            {
              entries: [4.16]
            }
          ]
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25]
            },
            {
              entries: [8.75]
            }
          ]
        }
      ]
    };
    setupNode(node);
    setupNode(expected);
    BTreeNode.shiftDown(node, 1);
    expect(node.entries.length).to.equal(1);
    expect(node.children[0].entries.length).to.equal(2);
    expect(node.children[1].entries.length).to.equal(1);
    expect(node.children.length).to.equal(2);
    expect(node.children[0].children.length).to.equal(3);
    expect(node.children[1].children.length).to.equal(2);
    expect(node).to.deep.equal(expected);
  });
  it('add duplicate', function() {
    const tree = {
      unique: true,
      max: 3,
      comparator: 'operator'
    }, node = {
      entries: [2.5, 5],
      children: [
        {
          entries: [1.25],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              tree
            },
            {
              entries: [8.75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 5, val = '5', expected = {
      entries: [2.5, 5],
      children: [
        {
          entries: [1.25],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              tree
            },
            {
              entries: [8.75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.add(node, key, val)).to.be.false;
  });
  it('add duplicate nonunique', function() {
    const tree = {
      unique: false,
      max: 3,
      comparator: 'operator'
    }, node = {
      entries: [2.5, 5],
      children: [
        {
          entries: [1.25],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              tree
            },
            {
              entries: [8.75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 5, val = 'five', expected = {
      entries: [2.5, 5],
      children: [
        {
          entries: [1.25],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              tree
            },
            {
              entries: [8.75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node, false);
    setupNode(expected, false);
    expected.entries[1].vals.push(val);
    expect(BTreeNode.add(node, key, val)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('add empty', function() {
    const tree = {
      unique: true,
      max: 3,
      comparator: 'operator'
    };
    const node = {
      entries: [],
      tree
    }, key = 9, val = '9', expected = {
      entries: [9],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.add(node, key, val)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('add one tail', function() {
    const tree = {
      unique: true,
      max: 3,
      comparator: 'operator'
    };
    const node = {
      entries: [2.5, ],
      tree
    }, key = 9, val = '9', expected = {
      entries: [2.5, 9],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.add(node, key, val)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('add one head', function() {
    const tree = {
      unique: true,
      max: 3,
      comparator: 'operator'
    };
    const node = {
      entries: [15, ],
      tree
    }, key = 9, val = '9', expected = {
      entries: [9, 15],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.add(node, key, val)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  if(false)
  it('add contrived', function() {
    const tree = {
      "unique": true,
      "min": 1,
      "max": 3,
      compare([a1, a2], [b1, b2]) {
        let d = a1 - b1;
        if(d != 0) return d;
        return a2 - b2;
      }
    };
    const node = {
      tree,
      "entries": [
        {
          "key": [
            1,
            3
          ],
          "val": 4
        }
      ]
    }, key = [3, 1], val = 4, expected = {
      tree,
      "entries": [
        {
          "key": [
            1,
            3
          ],
          "val": 4
        },
        {
          "key": [
            3,
            1
          ],
          "val": 4
        }
      ]
    };
    //setupNode(node);
    //setupNode(expected);
    expect(BTreeNode.add(node, key, val)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('add tail', function() {
    const tree = {
      unique: true,
      max: 3,
      comparator: 'operator'
    };
    const node = {
      entries: [2.5, 5],
      children: [
        {
          entries: [1.25],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              tree
            },
            {
              entries: [8.75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 9, val = '9', expected = {
      entries: [2.5, 5],
      children: [
        {
          entries: [1.25],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              tree
            },
            {
              entries: [8.75, 9],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.add(node, key, val)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('add head', function() {
    const tree = {
      unique: true,
      max: 3,
      comparator: 'operator'
    }, node = {
      entries: [2.5, 5],
      children: [
        {
          entries: [1.25],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              tree
            },
            {
              entries: [8.75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = .1, val = '' + .1, expected = {
      entries: [2.5, 5],
      children: [
        {
          entries: [1.25],
          children: [
            {
              entries: [.1, .625],
              tree
            },
            {
              entries: [1.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              tree
            },
            {
              entries: [8.75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node, tree);
    setupNode(expected, tree);
    expect(BTreeNode.add(node, key, val)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('add mid', function() {
    const tree = {
      unique: true,
      max: 3,
      comparator: 'operator'
    }, node = {
      entries: [2.5, 5],
      children: [
        {
          entries: [1.25],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              tree
            },
            {
              entries: [8.75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 3.5, val = '3.5', expected = {
      entries: [2.5, 5],
      children: [
        {
          entries: [1.25],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125, 3.5],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              tree
            },
            {
              entries: [8.75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node, tree);
    setupNode(expected, tree);
    expect(BTreeNode.add(node, key, val)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('add split', function() {
    const tree = {
      unique: true,
      max: 3,
      comparator: 'operator'
    };
    const node = {
      entries: [5],
      children: [
        {
          entries: [1.25, 2.5, 3.75],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            },
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [6.25, 7.5, 8.75],
          children: [
            {
              entries: [5.625],
              tree
            },
            {
              entries: [6.875],
              tree
            },
            {
              entries: [8.125],
              tree
            },
            {
              entries: [9.375],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 1, val = '1', expected = {
      entries: [2.5, 5],
      children: [
        {
          entries: [1.25],
          children: [
            {
              entries: [.625, 1],
              tree
            },
            {
              entries: [1.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [6.25, 7.5, 8.75],
          children: [
            {
              entries: [5.625],
              tree
            },
            {
              entries: [6.875],
              tree
            },
            {
              entries: [8.125],
              tree
            },
            {
              entries: [9.375],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(node.tree).to.not.be.null;
    expect(node.children[0]).to.not.be.null;
    expect(node.children[1]).to.not.be.null;
    expect(expected.tree).to.not.be.null;
    expect(expected.children[0]).to.not.be.null;
    expect(expected.children[1]).to.not.be.null;
    expect(expected.children[2]).to.not.be.null;
    expect(BTreeNode.add(node, key, val)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('add shift up', function() {
    const tree = {
      unique: true,
      max: 3,
      comparator: 'operator'
    };
    const node = {
      entries: [5],
      children: [
        {
          entries: [1.25, 2.5, 3.75],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            },
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5, 8.75],
          children: [
            {
              entries: [6.875],
              tree
            },
            {
              entries: [8.125],
              tree
            },
            {
              entries: [9.375],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 1, val = '1', expected = {
      entries: [3.75],
      children: [
        {
          entries: [1.25, 2.5],
          children: [
            {
              entries: [.625, 1],
              tree
            },
            {
              entries: [1.875],
              tree
            },
            {
              entries: [3.125],
              tree
            }
          ],
          tree
        },
        {
          entries: [5, 7.5, 8.75],
          children: [
            {
              entries: [4.375],
              tree
            },
            {
              entries: [6.875],
              tree
            },
            {
              entries: [8.125],
              tree
            },
            {
              entries: [9.375],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(node.tree).to.not.be.null;
    expect(node.children[0]).to.not.be.null;
    expect(node.children[1]).to.not.be.null;
    expect(expected.tree).to.not.be.null;
    expect(expected.children[0]).to.not.be.null;
    expect(expected.children[1]).to.not.be.null;
    expect(expected.children[2]).to.not.be.null;
    expect(BTreeNode.add(node, key, val)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('add shift down', function() {
    const tree = {
      unique: true,
      max: 3,
      comparator: 'operator'
    };
    const node = {
      entries: [5],
      children: [
        {
          entries: [1.25, 2.5],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            },
            {
              entries: [3.125],
              tree
            }
          ],
          tree
        },
        {
          entries: [6.25, 7.5, 8.75],
          children: [
            {
              entries: [5.625],
              tree
            },
            {
              entries: [6.875],
              tree
            },
            {
              entries: [8.125],
              tree
            },
            {
              entries: [9.375],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 7, val = '7', expected = {
      entries: [6.25],
      children: [
        {
          entries: [1.25, 2.5, 5],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            },
            {
              entries: [3.125],
              tree
            },
            {
              entries: [5.625],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5, 8.75],
          children: [
            {
              entries: [6.875, 7],
              tree
            },
            {
              entries: [8.125],
              tree
            },
            {
              entries: [9.375],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(node.tree).to.not.be.null;
    expect(node.children[0]).to.not.be.null;
    expect(node.children[1]).to.not.be.null;
    expect(expected.tree).to.not.be.null;
    expect(expected.children[0]).to.not.be.null;
    expect(expected.children[1]).to.not.be.null;
    expect(expected.children[2]).to.not.be.null;
    expect(BTreeNode.add(node, key, val)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('add splitRoot', function() {
    const tree = {
      unique: true,
      max: 3,
      comparator: 'operator'
    }, node = {
      entries: [0, 2.5, 5],
      children: [
        {
          entries: [-1],
          children: [
            {
              entries: [-1.5],
              tree
            },
            {
              entries: [-.5],
              tree
            }
          ]
        },
        {
          entries: [1.25],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            }
          ],
          tree
        },
        {
          entries: [3.75],
          children: [
            {
              entries: [3.125],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [7.5],
          children: [
            {
              entries: [6.25],
              tree
            },
            {
              entries: [8.75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 3.5, val = '3.5', expected = {
      entries: [2.5],
      children: [
        {
          entries: [0],
          children: [
            {
              entries: [-1],
              children: [
                {
                  entries: [-1.5],
                  tree
                },
                {
                  entries: [-.5],
                  tree
                }
              ]
            },
            {
              entries: [1.25],
              children: [
                {
                  entries: [.625],
                  tree
                },
                {
                  entries: [1.875],
                  tree
                }
              ],
              tree
            }
          ],
          tree
        },
        {
          entries: [5],
          children: [
            {
              entries: [3.75],
              children: [
                {
                  entries: [3.125, 3.5],
                  tree
                },
                {
                  entries: [4.375],
                  tree
                }
              ],
              tree
            },
            {
              entries: [7.5],
              children: [
                {
                  entries: [6.25],
                  tree
                },
                {
                  entries: [8.75],
                  tree
                }
              ],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node, tree);
    setupNode(expected, tree);
    expect(BTreeNode.add(node, key, val)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('popFirst', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [5],
      children: [
        {
          entries: [1.25, 2.5, 3.75],
          tree
        },
        {
          entries: [6.25, 7.5, 8.75],
          tree
        }
      ],
      tree
    }, key = 1.25, val = '1.25', expected = {
      entries: [5],
      children: [
        {
          entries: [2.5, 3.75],
          tree
        },
        {
          entries: [6.25, 7.5, 8.75],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.popFirst(node, 0)).to.deep.equal({key, val});
    expect(node).to.deep.equal(expected);
  });
  it('popFirst shiftDown', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [5],
      children: [
        {
          entries: [1.25],
          tree
        },
        {
          entries: [6.25, 7.5, 8.75],
          tree
        }
      ],
      tree
    }, key = 1.25, val = '1.25', expected = {
      entries: [6.25],
      children: [
        {
          entries: [5],
          tree
        },
        {
          entries: [7.5, 8.75],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.popFirst(node, 0)).to.deep.equal({key, val});
    expect(node).to.deep.equal(expected);
  });
  it('popFirst merge', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [5, 7.5],
      children: [
        {
          entries: [1.25],
          tree
        },
        {
          entries: [6.25],
          tree
        },
        {
          entries: [8.75],
          tree
        }
      ],
      tree
    }, key = 1.25, val = '1.25', expected = {
      entries: [7.5],
      children: [
        {
          entries: [5, 6.25],
          tree
        },
        {
          entries: [8.75],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.popFirst(node, 0)).to.deep.equal({key, val});
    expect(node.entries.length).to.equal(1);
    expect(node.children[0].entries.length).to.equal(2);
    expect(node.children[1].entries.length).to.equal(1);
    expect(node.children.length).to.equal(2);
    expect(node).to.deep.equal(expected);
  });
  it('popLast', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [5],
      children: [
        {
          entries: [1.25, 2.5, 3.75],
          tree
        },
        {
          entries: [6.25, 7.5, 8.75],
          tree
        }
      ],
      tree
    }, key = 8.75, val = '8.75', expected = {
      entries: [5],
      children: [
        {
          entries: [1.25, 2.5, 3.75],
          tree
        },
        {
          entries: [6.25, 7.5],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.popLast(node, 0)).to.deep.equal({key, val});
    expect(node).to.deep.equal(expected);
  });
  it('popLast shiftUp', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [5],
      children: [
        {
          entries: [1.25, 2.5, 3.75],
          tree
        },
        {
          entries: [8.75],
          tree
        }
      ],
      tree
    }, key = 8.75, val = '8.75', expected = {
      entries: [3.75],
      children: [
        {
          entries: [1.25, 2.5],
          tree
        },
        {
          entries: [5],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.popLast(node, 0)).to.deep.equal({key, val});
    expect(node).to.deep.equal(expected);
  });
  it('popLast merge', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [2.5, 5],
      children: [
        {
          entries: [1.25],
          tree
        },
        {
          entries: [3.75],
          tree
        },
        {
          entries: [8.75],
          tree
        }
      ],
      tree
    }, key = 8.75, val = '8.75', expected = {
      entries: [2.5],
      children: [
        {
          entries: [1.25],
          tree
        },
        {
          entries: [3.75, 5],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.popLast(node, 0)).to.deep.equal({key, val});
    expect(node).to.deep.equal(expected);
  });
  it('remove dne', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [5],
      children: [
        {
          entries: [1.25, 2.5, 3.75],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            },
            {
              entries: [2.8125, 3.125, 3.4375],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [6.25, 7.5, 8.75],
          children: [
            {
              entries: [5.625],
              tree
            },
            {
              entries: [6.875],
              tree
            },
            {
              entries: [8.126],
              tree
            },
            {
              entries: [9.375],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 3, expected = {
      entries: [5],
      children: [
        {
          entries: [1.25, 2.5, 3.75],
          children: [
            {
              entries: [.625],
              tree
            },
            {
              entries: [1.875],
              tree
            },
            {
              entries: [2.8125, 3.125, 3.4375],
              tree
            },
            {
              entries: [4.375],
              tree
            }
          ],
          tree
        },
        {
          entries: [6.25, 7.5, 8.75],
          children: [
            {
              entries: [5.625],
              tree
            },
            {
              entries: [6.875],
              tree
            },
            {
              entries: [8.126],
              tree
            },
            {
              entries: [9.375],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.remove(node, key)).to.be.false;
    expect(node).to.deep.equal(expected);
  });
  it('remove l1', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [20, 40, 60],
      tree
    }, key = 40, expected = {
      entries: [20, 60],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.remove(node, key)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('remove l2', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          tree
        },
        {
          entries: [50, 60, 70],
          tree
        }
      ],
      tree
    }, key = 20, expected = {
      entries: [40],
      children: [
        {
          entries: [10, 30],
          tree
        },
        {
          entries: [50, 60, 70],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.remove(node, key)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('remove l3', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15],
              tree
            },
            {
              entries: [24, 25, 23],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 25, expected = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15],
              tree
            },
            {
              entries: [24, 23],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.remove(node, key)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('remove shiftUp', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [40],
      children: [
        {
          entries: [10, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15, 20, 25],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 35, expected = {
      entries: [40],
      children: [
        {
          entries: [10, 25],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15, 20],
              tree
            },
            {
              entries: [30],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.remove(node, key)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('remove l3', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15],
              tree
            },
            {
              entries: [25],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55, 60, 65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 45, expected = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15],
              tree
            },
            {
              entries: [25],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [55, 70],
          children: [
            {
              entries: [50],
              tree
            },
            {
              entries: [60, 65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.remove(node, key)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('remove merge', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15],
              tree
            },
            {
              entries: [25],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 5, expected = {
      entries: [40],
      children: [
        {
          entries: [20, 30],
          children: [
            {
              entries: [10, 15],
              tree
            },
            {
              entries: [25],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.remove(node, key)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('remove popFirst', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15],
              tree
            },
            {
              entries: [25, 26],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 20, expected = {
      entries: [40],
      children: [
        {
          entries: [10, 25, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15],
              tree
            },
            {
              entries: [26],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.remove(node, key)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('remove popLast', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [14, 15],
              tree
            },
            {
              entries: [25],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 20, expected = {
      entries: [40],
      children: [
        {
          entries: [10, 15, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [14],
              tree
            },
            {
              entries: [25],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.remove(node, key)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('remove internal merge', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15],
              tree
            },
            {
              entries: [25],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 20, expected = {
      entries: [40],
      children: [
        {
          entries: [10, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15, 25],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.remove(node, key)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('remove l2 mergeRoot', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [40],
      children: [
        {
          entries: [20],
          tree
        },
        {
          entries: [60],
          tree
        }
      ],
      tree
    }, key = 20, expected = {
      entries: [40, 60],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.remove(node, key)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('remove l3 mergeRoot', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [40],
      children: [
        {
          entries: [20],
          children: [
            {
              entries: [15],
              tree
            },
            {
              entries: [24, 25, 23],
              tree
            }
          ],
          tree
        },
        {
          entries: [60],
          children: [
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            }
          ],
          tree
        }
      ],
      tree
    }, key = 25, expected = {
      entries: [20, 40, 60],
      children: [
        {
          entries: [15],
          tree
        },
        {
          entries: [24, 23],
          tree
        },
        {
          entries: [55],
          tree
        },
        {
          entries: [65],
          tree
        },
      ],
      tree
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.remove(node, key)).to.be.true;
    expect(node).to.deep.equal(expected);
  });
  it('toJSON', function() {
    const tree = {
      unique: true,
      max: 3,
      min: 1,
      comparator: 'operator'
    };
    const node = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          children: [
            {
              entries: [5],
              tree
            },
            {
              entries: [15],
              tree
            },
            {
              entries: [25],
              tree
            },
            {
              entries: [35],
              tree
            }
          ],
          tree
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45],
              tree
            },
            {
              entries: [55],
              tree
            },
            {
              entries: [65],
              tree
            },
            {
              entries: [75],
              tree
            }
          ],
          tree
        }
      ],
      tree
    };
    const expected = {
      entries: [40],
      children: [
        {
          entries: [10, 20, 30],
          children: [
            {
              entries: [5]
            },
            {
              entries: [15]
            },
            {
              entries: [25]
            },
            {
              entries: [35]
            }
          ]
        },
        {
          entries: [50, 60, 70],
          children: [
            {
              entries: [45]
            },
            {
              entries: [55]
            },
            {
              entries: [65]
            },
            {
              entries: [75]
            }
          ]
        }
      ]
    };
    setupNode(node);
    setupNode(expected);
    expect(BTreeNode.toJSON(node,)).to.deep.equal(expected);
  });
});

describe('BTree', function() {
  let BTree;
  beforeEach(function() {
    BTree = oaStruct.get('btree');
  });
  it('is not null', function() {
    expect(BTree).to.not.be.null;
  });
});

});
const oaStruct = require('./oa_struct.js');

/* web-start */

function BTreeNodeGen() {
  class BTreeNode {
    static #comparators = {
      difference: (a, b) => a - b,
      operator: (a, b) => {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }
    };
    static RegisterComparator(name, func) {
      if(BTreeNode.#comparators[name]) return;
      BTreeNode.#comparators[name] = func;
    }
    static Compare(tree, a, b) {
      let comparator = BTreeNode.#comparators[tree.comparator];
      if(!comparator) comparator = BTreeNode.#comparators.operator;
      return comparator(a, b);
    }
    
    static isValid(node) {
      if(node.tree == undefined) return false;
      if(node.tree.unique !== true && node.tree.unique !== false) return false;
    }
    static validate(node, prefix = []) {
      if(node.tree == undefined) throw new Error(`node[${prefix.map(v => v.join()).join()}] must reference parent tree`);
      if(node.tree.unique !== true && node.tree.unique !== false)
        throw new Error(`node[${prefix.map(v => v.join()).join()}].tree.unique must be truthy`);
      if(node.children) node.children.forEach((c, i) => {
        let bs = [];
        bs.push(i > 0 ? node.entries[i - 1].key : null);
        bs.push(i < node.entries.length ? node.entries[i].key : null);
        let p2 = prefix.concat(bs);
        if(c.tree != node.tree) throw new Error(`node[${p2.map(v => v.join()).join()}] must have the same tree as its parent`);
        BTreeNode.validate(c, p2);
      });
    }
    static init(tree) {
      return {
        tree,
        entries: []
      };
    }
    static propogateTree(node, tree) {
      if(!tree) tree = node.tree;
      if(node.children)
        node.children.forEach(child => {
          BTreeNode.propogateTree(child, tree);
        });
    }
    static size(node) {
      let s = node.entries.length;
      if(node.children) s = node.children.reduce((a, c) => {
        return a + BTreeNode.size(c);
      }, s);
      return s;
    }
    static at(node, key) {
      let i = 0;
      if(!node.tree) console.error(node);
      while(i < node.entries.length && BTreeNode.Compare(node.tree, node.entries[i].key, key) < 0) i++;
      if(i < node.entries.length && BTreeNode.Compare(node.tree, node.entries[i].key, key) == 0) {
        return node.tree.unique ? node.entries[i].val : node.entries[i].vals.map(v => v);
      }
      if(node.children) return BTreeNode.at(node.children[i], key);
    }
    static split(node, i) {
      let child = node.children[i];
      let n = Math.floor(child.entries.length / 2);
      let sibling = {
        entries: child.entries.splice(0, n),
        children: child.children ? child.children.splice(0, n + 1) : undefined,
        tree: {
          unique: node.tree.unique,
          max: node.tree.max,
          comparator: node.tree.comparator
        }
      };
      node.entries.splice(i, 0, child.entries.splice(0, 1)[0]);
      //if(!child.children) return;
      node.children.splice(i, 0, sibling);
    }
    static splitRoot(node) {
      let N = node.entries.length;
      let n = Math.floor(node.entries.length / 2);
      let right = {
        entries: node.entries.splice(n + 1, N - n - 1),
        children: node.children ? node.children.splice(n + 1, N - n) : undefined,
        tree: {
          unique: node.tree.unique,
          max: node.tree.max,
          comparator: node.tree.comparator
        }
      };
      let left = {
        entries: node.entries.splice(0, n),
        children: node.children ? node.children.splice(0, n + 1) : undefined,
        tree: {
          unique: node.tree.unique,
          max: node.tree.max,
          comparator: node.tree.comparator
        }
      };
      if(node.children)
        node.children.splice(0, 0, left, right);
      else
        node.children = [left, right];
    }
    static merge(node, i) {
      let child = node.children[i];
      let sibling = node.children[i + 1];
      child.entries.splice(child.entries.length, 0, node.entries.splice(i, 1)[0]);
      for(let j = 0; j < sibling.entries.length; j++)
        child.entries.splice(child.entries.length, 0, sibling.entries[j]);
      node.children.splice(i + 1, 1);
      if(!child.children) return;
      for(let j = 0; j < sibling.children.length; j++)
        child.children.splice(child.children.length, 0, sibling.children[j]);
    }
    static mergeRoot(node) {
      let N = node.entries.length;
      for(let i = N; i >= 0; i--) {
        let child = node.children.splice(i, 1)[0];
        let n = child.entries.length;
        for(let j = 0; j < n; j++) {
          node.entries.splice(i + j, 0, child.entries.splice(0, 1)[0]);
        }
        if(child.children) {
          for(let j = 0; j < n; j++) {
            node.children.splice(i + j, 0, child.children.splice(0, 1)[0]);
          }
          node.children.splice(i + n, 0, child.children.splice(0, 1)[0]);
        }
      }
      if(node.children.length == 0) delete node.children;
    }
    static shiftUp(node, i, n = 1) {
      let child = node.children[i];
      let sibling = node.children[i + 1];
      sibling.entries.splice(0, 0, node.entries.splice(i, 1)[0]);
      for(let j = 0; j < n - 1; j++)
        sibling.entries.splice(0, 0, child.entries[child.entries.length - 1 - j]);
      node.entries.splice(i, 0, child.entries[child.entries.length - n]);
      child.entries.splice(child.entries.length - n, n);
      if(!child.children) return;
      for(let j = 0; j < n; j++)
        sibling.children.splice(0, 0, child.children[child.children.length - 1 - j]);
      child.children.splice(child.children.length - n, n);
    }
    static shiftDown(node, i, n = 1) {
      let child = node.children[i];
      let sibling = node.children[i - 1];
      sibling.entries.splice(sibling.entries.length, 0, node.entries.splice(i - 1, 1)[0]);
      for(let j = 0; j < n - 1; j++)
        sibling.entries.splice(sibling.entries.length, 0, child.entries[j]);
      node.entries.splice(i - 1, 0, child.entries[n - 1]);
      child.entries.splice(0, n);
      if(!child.children) return;
      for(let j = 0; j < n; j++)
        sibling.children.splice(sibling.children.length, 0, child.children[j]);
      child.children.splice(0, n);
    }
    static add(node, key, val) {
      if(node.entries.length == node.tree.max) {
        BTreeNode.splitRoot(node);
      }
      let i = 0;
      if(!node.tree) console.error(node);
      while(i < node.entries.length && BTreeNode.Compare(node.tree, node.entries[i].key, key) < 0) i++;
      if(i < node.entries.length && BTreeNode.Compare(node.tree, node.entries[i].key, key) == 0) {
        if(node.tree.unique) return false;
        node.entries[i].vals.push(val);
        return true;
      }
      if(node.children) {
        if(node.children[i].entries.length == node.tree.max) {
          if(i > 0 && node.children[i - 1].entries.length < node.tree.max)
            BTreeNode.shiftDown(node, i);
          else if(i < node.tree.max && node.children[i + 1].entries.length < node.tree.max)
            BTreeNode.shiftUp(node, i);
          else {
            BTreeNode.split(node, i);
            if(BTreeNode.Compare(node.tree, node.entries[i].key, key) < 0) i++;
          }
        }
        BTreeNode.add(node.children[i], key, val);
      }
      else {
        if(node.tree.unique)
          node.entries.splice(i, 0, {key, val});
        else
          node.entries.splice(i, 0, {key, vals: [val]});
      }
      return true;
    }
    static popLast(node) {
      if(!node.children) {
        return node.entries.splice(node.entries.length - 1, 1)[0];
      }
      let i = node.entries.length;
      let child = node.children[i];
      if(child.entries.length == node.tree.min) {
        if(node.children[i - 1].entries.length > node.tree.min) BTreeNode.shiftUp(node, i - 1);
        else {
          --i;
          BTreeNode.merge(node, i);
          child = node.children[i];
        }
      }
      return BTreeNode.popLast(child);
    }
    static popFirst(node) {
      if(!node.children) {
        return node.entries.splice(0, 1)[0];
      }
      let i = 0;
      let child = node.children[i];
      if(child.entries.length == node.tree.min) {
        if(node.children[i + 1].entries.length > node.tree.min) BTreeNode.shiftDown(node, i + 1);
        else {
          BTreeNode.merge(node, i);
          child = node.children[i];
        }
      }
      return BTreeNode.popFirst(child);
    }
    static remove(node, key) {
      if(node.children && node.entries.length <= node.tree.min) {
        let {sum, /*max, i*/} = node.children.reduce((a, c, i) => {
          let n = c.entries.length;
          a.sum += n;
          if(n > a.max) {
            a.max = n;
            a.i = i;
          }
          return a;
        }, {sum: node.entries.length, max: 0, i: 0});
        if(sum <= node.tree.max)
          BTreeNode.mergeRoot(node);
        //else
          //BTreeNode.split
      }
      let i = 0;
      while(i < node.entries.length && BTreeNode.Compare(node.tree, node.entries[i].key, key) < 0) i++;
      if(i < node.entries.length && BTreeNode.Compare(node.tree, node.entries[i].key, key) == 0) {
        if(node.children) {
          if(node.children[i].entries.length == node.tree.min) {
            if(node.children[i + 1].entries.length == node.tree.min) {
              BTreeNode.merge(node, i);
              return BTreeNode.remove(node.children[i], key);
            }
            node.entries[i] = BTreeNode.popFirst(node.children[i + 1]);
          }
          else {
            node.entries[i] = BTreeNode.popLast(node.children[i]);
          }
        }
        else {
          node.entries.splice(i, 1);
        }
        return true;
      }
      if(node.children) {
        let child = node.children[i];
        if(child.entries.length == node.tree.min) {
          if(i == 0 && node.children[i + 1].entries.length > node.tree.min) BTreeNode.shiftDown(node, i + 1);
          else if(i > 0 && node.children[i - 1].entries.length > node.tree.min) BTreeNode.shiftUp(node, i - 1);
          else if(i == 0) {
            BTreeNode.merge(node, i);
            child = node.children[i];
          }
          else {
            --i;
            BTreeNode.merge(node, i);
            child = node.children[i];
          }
        }
        return BTreeNode.remove(child, key);
      }
      else {
        return false;
      }
    }
    static toJSON(node) {
      let {entries, children} = node;
      let json = {entries};
      if(node.children) json.children = children.map(c => BTreeNode.toJSON(c));
      return json;
    }
    /*
    static inOrderIterator(node) {
      let path = [{node, i: 0}];
      let cur = node;
      while(cur.children) {
        cur = cur.children[0];
        path.push({node: cur, i: 0});
      }
      let iterationCount = 0;
      const it = {
        next() {
          let result;
          let last = path[path.length - 1];
          while(last.i >= last.node.entries.length) {
            path.pop();
            last = path[path.length - 1];
          }
          if(path.length == 0) return { value: iterationCount, done: true };
          ++last.i;
          while(last.node.children) {
            last = {node: last.node.children[0], i: 0};
            path.push(last);
          }
          result = { value: last.node.entries[last.i], done: false };
          ++iterationCount;
          ++last.i;
          return result;
        }
      };
      return it;
    }
    //*/
    static *inOrderGenerator(node) {
      let iterationCount = 0;
      let n = node.entries.length;
      for (let i = 0; i < n; ++i) {
        if(node.children)
          for(let e of BTreeNode.inOrderGenerator(node.children[i])) {
            iterationCount++;
            yield e;
          }
        iterationCount++;
        yield node.entries[i];
      }
      if(node.children)
        for(let e of BTreeNode.inOrderGenerator(node.children[n])) {
          iterationCount++;
          yield e;
        }
      return iterationCount;
    }
    static *preOrderGenerator(node) {
      let iterationCount = 0;
      let n = node.entries.length;
      for (let i = 0; i < n; ++i) {
        iterationCount++;
        yield node.entries[i];
      }
      if(node.children)
        for (let i = 0; i <= n; ++i) {
          for(let e of BTreeNode.preOrderGenerator(node.children[i])) {
            iterationCount++;
            yield e;
          }
        }
      return iterationCount;
    }
    static *postOrderGenerator(node) {
      let iterationCount = 0;
      let n = node.entries.length;
      if(node.children)
        for (let i = 0; i <= n; ++i) {
          for(let e of BTreeNode.postOrderGenerator(node.children[i])) {
            iterationCount++;
            yield e;
          }
        }
      for (let i = 0; i < n; ++i) {
        iterationCount++;
        yield node.entries[i];
      }
      return iterationCount;
    }
  }
  
  return BTreeNode;
}
oaStruct.Register('btreeNode', BTreeNodeGen, []);

function BTreeGen(BTreeNode) {
  class BTree {
    #max;
    #min;
    #unique;
    #comparator;
    #root;
    constructor(max, min, unique, comparator, root) {
      this.#max = max;
      this.#min = min;
      this.#unique = unique;
      this.#comparator = comparator;
      if(root) BTreeNode.validate(root);
      this.#root = root ? root : {
        tree: this,
        entries: []
      };
    }
    get max() { return this.#max; }
    get min() { return this.#min; }
    get unique() { return this.#unique; }
    compare(a, b) { return this.#comparator(a, b); }
    size() {
      return BTreeNode.size(this.#root);
    }
    at(key) {
      return BTreeNode.at(this.#root, key);
    }
    add(key, val) {
      return BTreeNode.add(this.#root, key, val);
    }
    remove(key) {
      return BTreeNode.remove(this.#root, key);
    }
    toJSON() {
      return BTreeNode.toJSON(this.#root);
    }
  }

  return BTree;
}
oaStruct.Register('btree', BTreeGen, ['btreeNode']);

/* web-end */